diff --git a/src/include/duckdb.h b/src/include/duckdb.h
index b887b3732e..80f9d3ef83 100644
--- a/src/include/duckdb.h
+++ b/src/include/duckdb.h
@@ -1352,6 +1352,13 @@ The resulting type should be destroyed with `duckdb_destroy_logical_type`.
 DUCKDB_API duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types, const char **member_names,
                                                          idx_t member_count);


+
+DUCKDB_API duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types, const char **member_names,
+                                                         idx_t member_count);
+
+DUCKDB_API duckdb_logical_type duckdb_create_enum_type(const char *enum_name, const char **member_names, idx_t member_count);
+
+
+
+
 /*!
 Creates a `duckdb_logical_type` of type decimal with the specified width and scale
 The resulting type should be destroyed with `duckdb_destroy_logical_type`.
diff --git a/src/main/capi/logical_types-c.cpp b/src/main/capi/logical_types-c.cpp
index 83906f68c4..c758859e52 100644
--- a/src/main/capi/logical_types-c.cpp
+++ b/src/main/capi/logical_types-c.cpp
@@ -1,4 +1,8 @@
 #include "duckdb/main/capi/capi_internal.hpp"
+#include <duckdb/common/types/vector.hpp>
+#include <duckdb/storage/statistics/numeric_stats.hpp>
+#include <duckdb.hpp>
+#include <duckdb/common/types.hpp>
 
 static bool AssertLogicalTypeId(duckdb_logical_type type, duckdb::LogicalTypeId type_id) {
 	if (!type) {
@@ -73,6 +77,26 @@ duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types_
 	return reinterpret_cast<duckdb_logical_type>(mtype);
 }
 
+duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types_p, const char **member_names,
+                                              idx_t member_count) {
+       if (!member_types_p || !member_names) {
+               return nullptr;
+       }
+       duckdb::LogicalType **member_types = (duckdb::LogicalType **)member_types_p;
+       duckdb::LogicalType *mtype = new duckdb::LogicalType;
+       duckdb::child_list_t<duckdb::LogicalType> members;
+
+       for (idx_t i = 0; i < member_count; i++) {
+               members.push_back(make_pair(member_names[i], *member_types[i]));
+       }
+       *mtype = duckdb::LogicalType::STRUCT(members);
+       return reinterpret_cast<duckdb_logical_type>(mtype);
+}
+
+duckdb_logical_type duckdb_create_enum_type(const char *enum_name, const char **member_names, idx_t member_count) {
+	if (!enum_name || !member_names) {
+		return nullptr;
+	}
+	//duckdb::Vector* enum_vector = new duckdb::Vector(LogicalType::VARCHAR, member_count);
+	duckdb::Vector enum_vector(duckdb::LogicalType::VARCHAR, member_count);
+
+	auto enum_vector_ptr = duckdb::FlatVector::GetData<duckdb::string_t>(enum_vector);
+
+	for (idx_t i = 0; i < member_count; i++) {
+		enum_vector_ptr[i] = duckdb::StringVector::AddStringOrBlob(enum_vector, member_names[i]);
+	}
+
+	duckdb::LogicalType *mtype = new duckdb::LogicalType;
+	*mtype = duckdb::LogicalType::ENUM(enum_name, enum_vector, member_count);
+	//delete enum_vector;
+	return reinterpret_cast<duckdb_logical_type>(mtype);
+}
+
+
 duckdb_logical_type duckdb_create_map_type(duckdb_logical_type key_type, duckdb_logical_type value_type) {
 	if (!key_type || !value_type) {
 		return nullptr;
